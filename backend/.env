# Below is the **entire backend** implementation laid out *file-by-file* exactly matching your structure (with one small correction: Python packages require `__init__.py`, not `_init_.py`). Copy these into your project as-is.

# ---

# # Folder tree (backend only)

# ```
# backend/
# ├─ Dockerfile
# ├─ .env.example
# ├─ requirements.txt
# └─ app/
#    ├─ main.py
#    ├─ config.py
#    ├─ database.py
#    ├─ models/
#    │  ├─ __init__.py
#    │  ├─ user.py
#    │  ├─ session.py
#    │  └─ message.py
#    ├─ schemas/
#    │  ├─ __init__.py
#    │  ├─ auth.py
#    │  ├─ user.py
#    │  ├─ session.py
#    │  └─ message.py
#    ├─ api/
#    │  ├─ __init__.py
#    │  ├─ auth.py
#    │  ├─ sessions.py
#    │  ├─ messages.py
#    │  └─ sse.py
#    ├─ services/
#    │  ├─ __init__.py
#    │  ├─ streaming.py
#    │  ├─ rate_limiter.py
#    │  └─ providers/
#    │     ├─ __init__.py
#    │     ├─ base.py
#    │     ├─ openai_adapter.py
#    │     ├─ anthropic_adapter.py
#    │     └─ gemini_adapter.py
#    └─ utils/
#       ├─ __init__.py
#       ├─ security.py
#       └─ deps.py
# ```

# ---

# ## `backend/.env.example`

# ```env
# FastAPI
# App
APP_NAME=MultiProviderChat
APP_ENV=dev
APP_DEBUG=True

# Backend URL (frontend runs on port 3000)
CORS_ORIGINS=http://localhost:3000

# Database
# DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/aichat
# DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/aichat
# DATABASE_URL=postgresql+psycopg2://postgres:password@localhost:5432/aichat
DATABASE_URL=postgresql+asyncpg://postgres:password@localhost:5432/aichat



# DATABASE_URL=postgresql+psycopg2://app:password@localhost:5432/aichat

# JWT
JWT_SECRET=supersecretkey
JWT_EXPIRE_SECONDS=86400

# API Keys (fill if you have them)
# OPENAI_API_KEY=
# ANTHROPIC_API_KEY=
GEMINI_API_KEY="AIzaSyCWSs_piEQsvaal0vCNpM2zL8NXKt4wzGA"

# Defaults
DEFAULT_PROVIDER=openai
DEFAULT_MODEL=gpt-3.5-turbo


# # Default provider/model for new sessions
# DEFAULT_PROVIDER=openai
# DEFAULT_MODEL=gpt-3.5-turbo
# ```

# ---

# ## `backend/requirements.txt`

# ```txt
# fastapi==0.111.0
# uvicorn[standard]==0.30.0
# pydantic==2.7.4
# pydantic-settings==2.3.4
# sqlalchemy==2.0.30
# asyncpg==0.29.0
# passlib[bcrypt]==1.7.4
# python-jose[cryptography]==3.3.0
# python-multipart==0.0.9
# httpx==0.27.0
# anyio==4.4.0

# # Optional provider SDKs (installed but only used if API keys set)
# openai==1.30.5
# anthropic==0.30.0
# google-generativeai==0.7.2

# # utilities
# tenacity==8.2.3
# ```

# ---

# ## `backend/Dockerfile`

# ```dockerfile
# FROM python:3.11-slim
# WORKDIR /app
# ENV PYTHONDONTWRITEBYTECODE=1 \
#     PYTHONUNBUFFERED=1

# COPY requirements.txt .
# RUN pip install --no-cache-dir -r requirements.txt

# COPY app ./app

# EXPOSE 8000
# CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
# ```

# ---

# ## `backend/app/config.py`

# ```python
# from pydantic_settings import BaseSettings
# from pydantic import AnyHttpUrl
# from typing import List
# import os

# class Settings(BaseSettings):
#     APP_NAME: str = "MultiProviderChat"
#     APP_ENV: str = "dev"
#     APP_DEBUG: bool = True

#     CORS_ORIGINS: str = "http://localhost:3000"

#     DATABASE_URL: str

#     JWT_SECRET: str
#     JWT_EXPIRE_SECONDS: int = 86400

#     OPENAI_API_KEY: str | None = None
#     ANTHROPIC_API_KEY: str | None = None
#     GEMINI_API_KEY: str | None = None

#     DEFAULT_PROVIDER: str = "openai"
#     DEFAULT_MODEL: str = "gpt-3.5-turbo"

#     class Config:
#         env_file = os.path.join(os.path.dirname(__file__), "..", ".env")
#         env_file_encoding = "utf-8"

# settings = Settings(_env_file=os.getenv("ENV_FILE", None))
# ```

# ---

# ## `backend/app/database.py`

# ```python
# from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
# from sqlalchemy.orm import sessionmaker, declarative_base
# from .config import settings

# Base = declarative_base()

# engine = create_async_engine(
#     settings.DATABASE_URL,
#     echo=False,
#     pool_size=10,
#     max_overflow=20,
# )

# AsyncSessionLocal = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)

# async def get_db():
#     async with AsyncSessionLocal() as session:
#         yield session
# ```

# ---

# ## `backend/app/models/__init__.py`

# ```python
# from .user import User
# from .session import ChatSession
# from .message import Message

# __all__ = ["User", "ChatSession", "Message"]
# ```

# ---

# ## `backend/app/models/user.py`

# ```python
# import uuid
# from sqlalchemy import Column, String, DateTime
# from sqlalchemy.dialects.postgresql import UUID
# from sqlalchemy.sql import func
# from ..database import Base

# class User(Base):
#     __tablename__ = "users"

#     id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
#     username = Column(String(50), unique=True, nullable=False)
#     email = Column(String(100), unique=True, nullable=False)
#     password_hash = Column(String, nullable=False)
#     created_at = Column(DateTime(timezone=True), server_default=func.now())
#     last_login = Column(DateTime(timezone=True), nullable=True)
# ```

# ---

# ## `backend/app/models/session.py`

# ```python
# import uuid
# from sqlalchemy import Column, String, DateTime, ForeignKey
# from sqlalchemy.dialects.postgresql import UUID
# from sqlalchemy.orm import relationship
# from sqlalchemy.sql import func
# from ..database import Base

# class ChatSession(Base):
#     __tablename__ = "sessions"

#     id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
#     user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
#     title = Column(String(200), nullable=True)
#     provider = Column(String(50), nullable=True)
#     model = Column(String(100), nullable=True)
#     created_at = Column(DateTime(timezone=True), server_default=func.now())
#     updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

#     messages = relationship("Message", back_populates="session", cascade="all, delete-orphan")
# ```

# ---

# ## `backend/app/models/message.py`

# ```python
# import uuid
# from sqlalchemy import Column, String, DateTime, ForeignKey, Integer
# from sqlalchemy.dialects.postgresql import UUID
# from sqlalchemy.types import JSON
# from sqlalchemy.orm import relationship
# from sqlalchemy.sql import func
# from ..database import Base

# class Message(Base):
#     __tablename__ = "messages"

#     id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
#     session_id = Column(UUID(as_uuid=True), ForeignKey("sessions.id", ondelete="CASCADE"), nullable=False)
#     role = Column(String(16), nullable=False)  # 'user' | 'assistant' | 'system'
#     content = Column(String, nullable=False, default="")
#     provider = Column(String(50), nullable=True)
#     model = Column(String(100), nullable=True)
#     tokens_used = Column(Integer, nullable=False, default=0)
#     created_at = Column(DateTime(timezone=True), server_default=func.now())
#     metadata = Column(JSON, nullable=False, default=dict)

#     session = relationship("ChatSession", back_populates="messages")
# ```

# ---

# ## `backend/app/schemas/__init__.py`

# ```python
# from .auth import Token, LoginRequest, RegisterRequest
# from .user import UserOut
# from .session import SessionCreate, SessionOut, SessionUpdate
# from .message import MessageCreate, MessageOut

# __all__ = [
#     "Token",
#     "LoginRequest",
#     "RegisterRequest",
#     "UserOut",
#     "SessionCreate",
#     "SessionOut",
#     "SessionUpdate",
#     "MessageCreate",
#     "MessageOut",
# ]
# ```

# ---

# ## `backend/app/schemas/auth.py`

# ```python
# from pydantic import BaseModel, EmailStr

# class RegisterRequest(BaseModel):
#     username: str
#     email: EmailStr
#     password: str

# class LoginRequest(BaseModel):
#     email: EmailStr
#     password: str

# class Token(BaseModel):
#     access_token: str
#     token_type: str = "bearer"
# ```

# ---

# ## `backend/app/schemas/user.py`

# ```python
# from pydantic import BaseModel, EmailStr
# from uuid import UUID
# from datetime import datetime

# class UserOut(BaseModel):
#     id: UUID
#     username: str
#     email: EmailStr
#     created_at: datetime

#     class Config:
#         from_attributes = True
# ```

# ---

# ## `backend/app/schemas/session.py`

# ```python
# from pydantic import BaseModel
# from typing import Optional
# from uuid import UUID
# from datetime import datetime

# class SessionCreate(BaseModel):
#     title: Optional[str] = None
#     provider: Optional[str] = None
#     model: Optional[str] = None

# class SessionUpdate(BaseModel):
#     title: Optional[str] = None
#     provider: Optional[str] = None
#     model: Optional[str] = None

# class SessionOut(BaseModel):
#     id: UUID
#     title: Optional[str]
#     provider: Optional[str]
#     model: Optional[str]
#     created_at: datetime
#     updated_at: datetime

#     class Config:
#         from_attributes = True
# ```

# ---

# ## `backend/app/schemas/message.py`

# ```python
# from pydantic import BaseModel
# from typing import Optional, Any
# from uuid import UUID
# from datetime import datetime

# class MessageCreate(BaseModel):
#     content: str

# class MessageOut(BaseModel):
#     id: UUID
#     session_id: UUID
#     role: str
#     content: str
#     provider: Optional[str]
#     model: Optional[str]
#     tokens_used: int
#     created_at: datetime
#     metadata: Any

#     class Config:
#         from_attributes = True
# ```

# ---

# ## `backend/app/utils/security.py`

# ```python
# import time
# from typing import Optional
# from jose import jwt
# from passlib.context import CryptContext
# from ..config import settings

# pwd_ctx = CryptContext(schemes=["bcrypt"], deprecated="auto")
# ALGORITHM = "HS256"

# def hash_password(pw: str) -> str:
#     return pwd_ctx.hash(pw)

# def verify_password(pw: str, hashed: str) -> bool:
#     return pwd_ctx.verify(pw, hashed)

# def create_access_token(sub: str) -> str:
#     payload = {"sub": sub, "exp": int(time.time()) + settings.JWT_EXPIRE_SECONDS}
#     return jwt.encode(payload, settings.JWT_SECRET, algorithm=ALGORITHM)

# def decode_token(token: str) -> Optional[dict]:
#     try:
#         return jwt.decode(token, settings.JWT_SECRET, algorithms=[ALGORITHM])
#     except Exception:
#         return None
# ```

# ---

# ## `backend/app/utils/deps.py`

# ```python
# from fastapi import Depends, HTTPException, Request
# from sqlalchemy.ext.asyncio import AsyncSession
# from sqlalchemy import select
# from ..database import get_db
# from ..models import User
# from .security import decode_token

# async def get_current_user(request: Request, db: AsyncSession = Depends(get_db)) -> User:
#     # Try Authorization header first
#     auth = request.headers.get("Authorization", "")
#     token = None
#     if auth.startswith("Bearer "):
#         token = auth[7:]
#     # Fallback for SSE (EventSource can't set headers)
#     if token is None:
#         token = request.query_params.get("access_token")
#     if not token:
#         raise HTTPException(status_code=401, detail="Missing token")

#     payload = decode_token(token)
#     if not payload or "sub" not in payload:
#         raise HTTPException(status_code=401, detail="Invalid token")

#     user_id = payload["sub"]
#     result = await db.execute(select(User).where(User.id == user_id))
#     user = result.scalar_one_or_none()
#     if not user:
#         raise HTTPException(status_code=401, detail="User not found")
#     return user
# ```

# ---

# ## `backend/app/api/__init__.py`

# ```python
# # empty to make it a package
# ```

# ---

# ## `backend/app/api/auth.py`

# ```python
# from fastapi import APIRouter, Depends, HTTPException
# from sqlalchemy.ext.asyncio import AsyncSession
# from sqlalchemy import select
# from ..database import get_db
# from ..models import User
# from ..schemas import RegisterRequest, LoginRequest, Token, UserOut
# from ..utils.security import hash_password, verify_password, create_access_token

# router = APIRouter(prefix="/auth", tags=["auth"])

# @router.post("/register", response_model=UserOut)
# async def register(payload: RegisterRequest, db: AsyncSession = Depends(get_db)):
#     # Check uniqueness
#     res1 = await db.execute(select(User).where(User.email == payload.email))
#     if res1.scalar_one_or_none():
#         raise HTTPException(400, detail="Email already registered")
#     res2 = await db.execute(select(User).where(User.username == payload.username))
#     if res2.scalar_one_or_none():
#         raise HTTPException(400, detail="Username already taken")

#     user = User(
#         username=payload.username,
#         email=payload.email,
#         password_hash=hash_password(payload.password),
#     )
#     db.add(user)
#     await db.commit()
#     await db.refresh(user)
#     return user

# @router.post("/login", response_model=Token)
# async def login(payload: LoginRequest, db: AsyncSession = Depends(get_db)):
#     res = await db.execute(select(User).where(User.email == payload.email))
#     user = res.scalar_one_or_none()
#     if not user or not verify_password(payload.password, user.password_hash):
#         raise HTTPException(401, detail="Invalid credentials")
#     token = create_access_token(str(user.id))
#     return Token(access_token=token)
# ```

# ---

# ## `backend/app/api/sessions.py`

# ```python
# from fastapi import APIRouter, Depends, HTTPException
# from sqlalchemy.ext.asyncio import AsyncSession
# from sqlalchemy import select
# from typing import List
# from ..database import get_db
# from ..models import ChatSession
# from ..schemas import SessionCreate, SessionOut, SessionUpdate
# from ..utils.deps import get_current_user
# from ..config import settings

# router = APIRouter(prefix="/sessions", tags=["sessions"])

# @router.get("/", response_model=List[SessionOut])
# async def list_sessions(db: AsyncSession = Depends(get_db), user=Depends(get_current_user)):
#     res = await db.execute(select(ChatSession).where(ChatSession.user_id == user.id).order_by(ChatSession.created_at.desc()))
#     return res.scalars().all()

# @router.post("/", response_model=SessionOut)
# async def create_session(payload: SessionCreate, db: AsyncSession = Depends(get_db), user=Depends(get_current_user)):
#     provider = payload.provider or settings.DEFAULT_PROVIDER
#     model = payload.model or settings.DEFAULT_MODEL
#     sess = ChatSession(user_id=user.id, title=payload.title, provider=provider, model=model)
#     db.add(sess)
#     await db.commit()
#     await db.refresh(sess)
#     return sess

# @router.get("/{session_id}", response_model=SessionOut)
# async def get_session(session_id: str, db: AsyncSession = Depends(get_db), user=Depends(get_current_user)):
#     sess = await db.get(ChatSession, session_id)
#     if not sess or sess.user_id != user.id:
#         raise HTTPException(404, detail="Session not found")
#     return sess

# @router.patch("/{session_id}", response_model=SessionOut)
# async def update_session(session_id: str, payload: SessionUpdate, db: AsyncSession = Depends(get_db), user=Depends(get_current_user)):
#     sess = await db.get(ChatSession, session_id)
#     if not sess or sess.user_id != user.id:
#         raise HTTPException(404, detail="Session not found")
#     if payload.title is not None:
#         sess.title = payload.title
#     if payload.provider is not None:
#         sess.provider = payload.provider
#     if payload.model is not None:
#         sess.model = payload.model
#     await db.commit()
#     await db.refresh(sess)
#     return sess

# @router.delete("/{session_id}")
# async def delete_session(session_id: str, db: AsyncSession = Depends(get_db), user=Depends(get_current_user)):
#     sess = await db.get(ChatSession, session_id)
#     if not sess or sess.user_id != user.id:
#         raise HTTPException(404, detail="Session not found")
#     await db.delete(sess)
#     await db.commit()
# ```
